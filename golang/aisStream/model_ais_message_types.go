/*
Ais-Stream WebsocketObjects

A sample API to illustrate OpenAPI concepts

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package aisStream

import (
	"encoding/json"
	"fmt"
)

// AisMessageTypes the model 'AisMessageTypes'
type AisMessageTypes string

// List of AisMessageTypes
const (
	POSITION_REPORT AisMessageTypes = "PositionReport"
	UNKNOWN_MESSAGE_TYPE AisMessageTypes = "UnknownMessageType"
	ADDRESSED_SAFETY_MESSAGE AisMessageTypes = "AddressedSafetyMessage"
	ADDRESSED_BINARY_MESSAGE AisMessageTypes = "AddressedBinaryMessage"
	AIDS_TO_NAVIGATION_REPORT AisMessageTypes = "AidsToNavigationReport"
	ASSIGNED_MODE_COMMAND AisMessageTypes = "AssignedModeCommand"
	ASSIGNED_MODE_COMMAND_DATA AisMessageTypes = "AssignedModeCommandData"
	BASE_STATION_REPORT AisMessageTypes = "BaseStationReport"
	BINARY_ACKNOWLEDGE AisMessageTypes = "BinaryAcknowledge"
	BINARY_BROADCAST_MESSAGE AisMessageTypes = "BinaryBroadcastMessage"
	CHANNEL_MANAGEMENT AisMessageTypes = "ChannelManagement"
	COMMUNICATION_STATE_ITDMA AisMessageTypes = "CommunicationStateItdma"
	COMMUNICATION_STATE_NO_ITDMA AisMessageTypes = "CommunicationStateNoItdma"
	COORDINATED_UTC_INQUIRY AisMessageTypes = "CoordinatedUTCInquiry"
	DATA_LINK_MANAGEMENT_MESSAGE AisMessageTypes = "DataLinkManagementMessage"
	DATA_LINK_MANAGEMENT_MESSAGE_DATA AisMessageTypes = "DataLinkManagementMessageData"
	EXTENDED_CLASS_B_POSITION_REPORT AisMessageTypes = "ExtendedClassBPositionReport"
	GNSS_BROADCAST_BINARY_MESSAGE_TYPE AisMessageTypes = "GnssBroadcastBinaryMessageType"
	GROUP_ASSIGNMENT_COMMAND AisMessageTypes = "GroupAssignmentCommand"
	INTERROGATION AisMessageTypes = "Interrogation"
	LONG_RANGE_AIS_BROADCAST_MESSAGE AisMessageTypes = "LongRangeAisBroadcastMessage"
	MULTI_SLOT_BINARY_MESSAGE AisMessageTypes = "MultiSlotBinaryMessage"
	SAFETY_BROADCAST_MESSAGE AisMessageTypes = "SafetyBroadcastMessage"
	SHIP_STATIC_DATA AisMessageTypes = "ShipStaticData"
	SINGLE_SLOT_BINARY_MESSAGE AisMessageTypes = "SingleSlotBinaryMessage"
	STANDARD_CLASS_B_POSITION_REPORT AisMessageTypes = "StandardClassBPositionReport"
	STANDARD_SEARCH_AND_RESCUE_AIRCRAFT_REPORT AisMessageTypes = "StandardSearchAndRescueAircraftReport"
	STATIC_DATA_REPORT AisMessageTypes = "StaticDataReport"
)

// All allowed values of AisMessageTypes enum
var AllowedAisMessageTypesEnumValues = []AisMessageTypes{
	"PositionReport",
	"UnknownMessageType",
	"AddressedSafetyMessage",
	"AddressedBinaryMessage",
	"AidsToNavigationReport",
	"AssignedModeCommand",
	"AssignedModeCommandData",
	"BaseStationReport",
	"BinaryAcknowledge",
	"BinaryBroadcastMessage",
	"ChannelManagement",
	"CommunicationStateItdma",
	"CommunicationStateNoItdma",
	"CoordinatedUTCInquiry",
	"DataLinkManagementMessage",
	"DataLinkManagementMessageData",
	"ExtendedClassBPositionReport",
	"GnssBroadcastBinaryMessageType",
	"GroupAssignmentCommand",
	"Interrogation",
	"LongRangeAisBroadcastMessage",
	"MultiSlotBinaryMessage",
	"SafetyBroadcastMessage",
	"ShipStaticData",
	"SingleSlotBinaryMessage",
	"StandardClassBPositionReport",
	"StandardSearchAndRescueAircraftReport",
	"StaticDataReport",
}

func (v *AisMessageTypes) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := AisMessageTypes(value)
	for _, existing := range AllowedAisMessageTypesEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid AisMessageTypes", value)
}

// NewAisMessageTypesFromValue returns a pointer to a valid AisMessageTypes
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewAisMessageTypesFromValue(v string) (*AisMessageTypes, error) {
	ev := AisMessageTypes(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for AisMessageTypes: valid values are %v", v, AllowedAisMessageTypesEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v AisMessageTypes) IsValid() bool {
	for _, existing := range AllowedAisMessageTypesEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to AisMessageTypes value
func (v AisMessageTypes) Ptr() *AisMessageTypes {
	return &v
}

type NullableAisMessageTypes struct {
	value *AisMessageTypes
	isSet bool
}

func (v NullableAisMessageTypes) Get() *AisMessageTypes {
	return v.value
}

func (v *NullableAisMessageTypes) Set(val *AisMessageTypes) {
	v.value = val
	v.isSet = true
}

func (v NullableAisMessageTypes) IsSet() bool {
	return v.isSet
}

func (v *NullableAisMessageTypes) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAisMessageTypes(val *AisMessageTypes) *NullableAisMessageTypes {
	return &NullableAisMessageTypes{value: val, isSet: true}
}

func (v NullableAisMessageTypes) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAisMessageTypes) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

